"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  cleanup: true,
  render: true,
  fireEvent: true
};
exports.cleanup = cleanup;
exports.render = render;
exports.fireEvent = fireEvent;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _testUtils = require("@vue/test-utils");

var _dom = require("@testing-library/dom");

Object.keys(_dom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _dom[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _dom[key];
    }
  });
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var mountedWrappers = new Set();

function render(TestComponent) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$store = _ref.store,
      store = _ref$store === void 0 ? null : _ref$store,
      _ref$routes = _ref.routes,
      routes = _ref$routes === void 0 ? null : _ref$routes,
      customContainer = _ref.container,
      customBaseElement = _ref.baseElement,
      mountOptions = (0, _objectWithoutProperties2["default"])(_ref, ["store", "routes", "container", "baseElement"]);

  var configurationCb = arguments.length > 2 ? arguments[2] : undefined;
  var div = document.createElement('div');
  var baseElement = customBaseElement || customContainer || document.body;
  var container = customContainer || baseElement.appendChild(div);
  var attachTo = document.createElement('div');
  container.appendChild(attachTo);
  var localVue = (0, _testUtils.createLocalVue)();
  var vuexStore = null;
  var router = null;
  var additionalOptions = {};

  if (store) {
    var Vuex = require('vuex');

    localVue.use(Vuex);
    vuexStore = new Vuex.Store(store);
  }

  if (routes) {
    var requiredRouter = require('vue-router');

    var VueRouter = requiredRouter["default"] || requiredRouter;
    localVue.use(VueRouter);
    router = new VueRouter({
      routes: routes
    });
  }

  if (configurationCb && typeof configurationCb === 'function') {
    additionalOptions = configurationCb(localVue, vuexStore, router);
  }

  if (!mountOptions.propsData && !!mountOptions.props) {
    mountOptions.propsData = mountOptions.props;
    delete mountOptions.props;
  }

  var wrapper = (0, _testUtils.mount)(TestComponent, _objectSpread(_objectSpread({
    localVue: localVue,
    router: router,
    attachTo: attachTo,
    store: vuexStore
  }, mountOptions), additionalOptions));
  mountedWrappers.add(wrapper);
  container.appendChild(wrapper.element);
  return _objectSpread({
    container: container,
    baseElement: baseElement,
    debug: function debug() {
      var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : baseElement;
      var maxLength = arguments.length > 1 ? arguments[1] : undefined;
      var options = arguments.length > 2 ? arguments[2] : undefined;
      return Array.isArray(el) ? el.forEach(function (e) {
        return console.log((0, _dom.prettyDOM)(e, maxLength, options));
      }) : console.log((0, _dom.prettyDOM)(el, maxLength, options));
    },
    unmount: function unmount() {
      return wrapper.destroy();
    },
    isUnmounted: function isUnmounted() {
      return wrapper.vm._isDestroyed;
    },
    html: function html() {
      return wrapper.html();
    },
    emitted: function emitted() {
      return wrapper.emitted();
    },
    updateProps: function updateProps(_) {
      return wrapper.setProps(_);
    }
  }, (0, _dom.getQueriesForElement)(baseElement));
}

function cleanup() {
  mountedWrappers.forEach(cleanupAtWrapper);
}

function cleanupAtWrapper(wrapper) {
  if (wrapper.element.parentNode && wrapper.element.parentNode.parentNode === document.body) {
    document.body.removeChild(wrapper.element.parentNode);
  }

  try {
    wrapper.destroy();
  } finally {
    mountedWrappers["delete"](wrapper);
  }
} // Vue Testing Library's version of fireEvent will call DOM Testing Library's
// version of fireEvent plus wait for one tick of the event loop to allow Vue
// to asynchronously handle the event.
// More info: https://vuejs.org/v2/guide/reactivity.html#Async-Update-Queue


function fireEvent() {
  return _fireEvent.apply(this, arguments);
}

function _fireEvent() {
  _fireEvent = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
    var _args3 = arguments;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _dom.fireEvent.apply(void 0, _args3);

            _context3.next = 3;
            return (0, _dom.waitFor)(function () {});

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fireEvent.apply(this, arguments);
}

var changeOrInputEventCalledDirectly = function changeOrInputEventCalledDirectly(eventValue, eventKey) {
  return eventValue && (eventKey === 'change' || eventKey === 'input');
};

Object.keys(_dom.fireEvent).forEach(function (key) {
  fireEvent[key] = /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    var _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (changeOrInputEventCalledDirectly(_args.length <= 1 ? undefined : _args[1], key) && !process.env.VTL_SKIP_WARN_EVENT_UPDATE) {
              console.warn("Using \"fireEvent.".concat(key, " may lead to unexpected results. Please use fireEvent.update() instead."));
            }

            _dom.fireEvent[key].apply(_dom.fireEvent, _args);

            _context.next = 4;
            return (0, _dom.waitFor)(function () {});

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
});

fireEvent.touch = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(elem) {
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return fireEvent.focus(elem);

          case 2:
            _context2.next = 4;
            return fireEvent.blur(elem);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x) {
    return _ref3.apply(this, arguments);
  };
}(); // Small utility to provide a better experience when working with v-model.
// Related upstream issue: https://github.com/vuejs/vue-test-utils/issues/345#issuecomment-380588199
// Examples: https://github.com/testing-library/vue-testing-library/blob/master/src/__tests__/form.js


fireEvent.update = function (elem, value) {
  var tagName = elem.tagName;
  var type = elem.type;

  switch (tagName) {
    case 'OPTION':
      {
        elem.selected = true;
        var parentSelectElement = elem.parentElement.tagName === 'OPTGROUP' ? elem.parentElement.parentElement : elem.parentElement;
        return fireEvent.change(parentSelectElement);
      }

    case 'INPUT':
      {
        if (['checkbox', 'radio'].includes(type)) {
          elem.checked = true;
          return fireEvent.change(elem);
        } else if (type === 'file') {
          return fireEvent.change(elem);
        } else {
          elem.value = value;

          if (elem._vModifiers && elem._vModifiers.lazy) {
            return fireEvent.change(elem);
          }

          return fireEvent.input(elem);
        }
      }

    case 'TEXTAREA':
      {
        elem.value = value;

        if (elem._vModifiers && elem._vModifiers.lazy) {
          return fireEvent.change(elem);
        }

        return fireEvent.input(elem);
      }

    case 'SELECT':
      {
        elem.value = value;
        return fireEvent.change(elem);
      }

    default: // do nothing

  }

  return null;
}; // If we're running in a test runner that supports afterEach then we'll
// automatically run cleanup after each test. This ensures that tests run in
// isolation from each other.
// If you don't like this, set the VTL_SKIP_AUTO_CLEANUP variable to 'true'.


if (typeof afterEach === 'function' && !process.env.VTL_SKIP_AUTO_CLEANUP) {
  afterEach(function () {
    cleanup();
  });
}